var documenterSearchIndex = {"docs":
[{"location":"api/declaremissings/#Declaring-Missings","page":"Declare Missings","title":"Declaring Missings","text":"","category":"section"},{"location":"api/declaremissings/","page":"Declare Missings","title":"Declare Missings","text":"Impute.declaremissings","category":"page"},{"location":"api/declaremissings/#Impute.declaremissings","page":"Declare Missings","title":"Impute.declaremissings","text":"Impute.declaremissings(data; values)\n\nDeclareMissings (or replace) various missing data representations with missing.\n\nKeyword Arguments\n\nvalue::Tuple: A tuple of values that should be considered missing\n\nExample\n\njulia> using DataFrames, Impute\n\n\njulia> df = DataFrame(\n           :a => [1.1, 2.2, NaN, NaN, 5.5],\n           :b => [1, 2, 3, -9999, 5],\n           :c => [\"v\", \"w\", \"x\", \"y\", \"NULL\"],\n       )\n5×3 DataFrame\n Row │ a        b      c\n     │ Float64  Int64  String\n─────┼────────────────────────\n   1 │     1.1      1  v\n   2 │     2.2      2  w\n   3 │   NaN        3  x\n   4 │   NaN    -9999  y\n   5 │     5.5      5  NULL\n\njulia> Impute.declaremissings(df; values=(NaN, -9999, \"NULL\"))\n5×3 DataFrame\n Row │ a          b        c\n     │ Float64?   Int64?   String?\n─────┼─────────────────────────────\n   1 │       1.1        1  v\n   2 │       2.2        2  w\n   3 │ missing          3  x\n   4 │ missing    missing  y\n   5 │       5.5        5  missing\n\n\n\n\n\n","category":"function"},{"location":"api/declaremissings/","page":"Declare Missings","title":"Declare Missings","text":"Impute.DeclareMissings","category":"page"},{"location":"api/declaremissings/#Impute.DeclareMissings","page":"Declare Missings","title":"Impute.DeclareMissings","text":"DeclareMissings(; values)\n\nDeclareMissings (or replace) various missing data values with missing. This is useful for downstream imputation methods that assume missing data is represented by a missing.\n\n!!! In-place methods are only applicable for datasets which already allowmissing.\n\nKeyword Arguments\n\nvalue::Tuple: A tuple of values that should be considered missing\n\nExample\n\njulia> using Impute: DeclareMissings, apply\n\njulia> M = [1.0 2.0 -9999.0 NaN 5.0; 1.1 2.2 3.3 0.0 5.5]\n2×5 Array{Float64,2}:\n 1.0  2.0  -9999.0  NaN    5.0\n 1.1  2.2      3.3    0.0  5.5\n\njulia> apply(M, DeclareMissings(; values=(NaN, -9999.0, 0.0)))\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\n\n\n\n\n","category":"type"},{"location":"walkthroughs/spatiotemporal/#Spatiotemporal-Panel-Datasets","page":"Spatiotemporal","title":"Spatiotemporal Panel Datasets","text":"","category":"section"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"We often also need to missing data in spatiotemporal data. For this example, we'll use daily temperature values from major cities around the world.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"TODO: Give a different workflow/example using a DataFrame.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"using AxisKeys, Impute, NamedDims, Plots, Statistics, StatsBase\n\n# So NamedDimsArray is the outer wrapper\nAxisKeys.nameouter() = true\n\n# Construct a KeyedArray of our dataset as we want to track gaps (or missing rows)\n# in the source CSV data.\ndata = wrapdims(\n    Impute.dataset(\"test/table/temperature\"),\n    :AverageTemperature,\n    :dt,\n    :City;\n    default=missing,\n    sort=true,\n)\n\n# Rename our dims\ndata = rename(data, :dt => :time, :City => :loc)","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"Okay, so let's take a look at how much temperature data is missing.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"heatmap(ismissing.(data); color=:greys);\nsavefig(\"st-missing-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"(Image: )","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"So many cities are missing a lot of historical data. A common operation is to remove locations with too many missing historical observations. In our case, we also want to penalize observations closer to the present.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"Lets start be define a set of exponential weights for our observations:","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"wv = eweights(1:length(data.time), 0.001)\nplot(wv);\nsavefig(\"st-wv-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"(Image: )","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"Now we want to filter out locations (columns) according to those weights. For now, we'll say that a location should be removed if the weighted ratio exceeds 0.1.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"data = Impute.filter(data; dims=:cols) do v\n    mratio = sum(wv[ismissing.(v)]) / sum(wv)\n    return mratio < 0.1\nend","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"Okay, so we removed almost 25% of the locations that didn't meet our missing data requirement. However, most of our observations from the 1700's are still mostly missing. Let's remove those rows that have more 50% of the locations missing.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"data = Impute.filter(data; dims=:rows) do v\n    mratio = count(ismissing, v) / length(v)\n    return mratio < 0.5\nend","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"Now let's take a look at what data remains.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"heatmap(ismissing.(data); color=:greys);\nsavefig(\"st-missing-reduced-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"(Image: )","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"Alright, we can work with the remaining missing values now. Now we could try simply imputing the values columnwise for each city using something like Impute.nocb","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"heatmap(Impute.nocb(data; dims=:cols));\nsavefig(\"st-nocb-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"(Image: )","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"But, this looks rather crude and creates clear artifacts in the dataset. Since we suspect that observations in similar locations would have had similar recordings we could use Impute.svd or Impute.knn to find similarities across multiple locations.","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"data = Impute.knn(data; dims=:cols, k=4);\nheatmap(data);\nsavefig(\"st-knn-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"(Image: )","category":"page"},{"location":"walkthroughs/spatiotemporal/","page":"Spatiotemporal","title":"Spatiotemporal","text":"This method appears to have removed the artifacts found with the basic NOCB method alone. Now we have a complete dataset ready for downstream processing :)","category":"page"},{"location":"api/imputation/#Imputation","page":"Imputation","title":"Imputation","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Modules = [Impute]\nPages = [\"imputors.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/imputation/#Impute.Imputor","page":"Imputation","title":"Impute.Imputor","text":"Imputor\n\nAn imputor stores information about imputing values in AbstractArrays and Tables.tables. New imputation methods are expected to subtype Imputor and, at minimum, implement the _impute!(data::AbstractArrays, imp::<MyImputor>) method.\n\nWhile fallback impute and impute! methods are provided to extend your _impute! methods to n-dimensional arrays and tables, you can always override these methods to change the behaviour as necessary.\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#Impute.impute!-Tuple{AbstractArray,Impute.Imputor}","page":"Imputation","title":"Impute.impute!","text":"impute!(data::AbstractArray, imp) -> data\n\nJust returns the data when the array doesn't contain missings\n\n\n\n\n\n","category":"method"},{"location":"api/imputation/#Impute.impute!-Tuple{AbstractArray{Missing,N} where N,Impute.Imputor}","page":"Imputation","title":"Impute.impute!","text":"impute!(data::AbstractArray{Missing}, imp) -> data\n\nJust return the data when the array only contains missings\n\n\n\n\n\n","category":"method"},{"location":"api/imputation/#Impute.impute!-Union{Tuple{A}, Tuple{T}, Tuple{A,Impute.Imputor}} where A<:(AbstractArray{Union{Missing, T},N} where N) where T","page":"Imputation","title":"Impute.impute!","text":"impute!(data::A, imp; dims=:, kwargs...) -> A\n\nImpute the missing values in the array data using the imputor imp. Optionally, you can specify the dimension to impute along.\n\nArguments\n\ndata::AbstractArray{Union{T, Missing}}: the data to be impute along dimensions dims\nimp::Imputor: the Imputor method to use\n\nKeyword Arguments\n\ndims=:: The dimension to impute along. :rows and :cols are also supported for matrices.\n\nReturns\n\nAbstractArray{Union{T, Missing}}: the input data with values imputed\n\nNOTES\n\nMatrices have a deprecated dims=2 special case as dims=: is a breaking change\nMutation isn't guaranteed for all array types, hence we return the result\neachslice is used internally which requires Julia 1.1\n\nExample\n\njulia> using Impute: Interpolate, impute!\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute!(M, Interpolate(); dims=1)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  3.0  4.0  5.0\n 1.1  2.2  3.3  4.4  5.5\n\njulia> M\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  3.0  4.0  5.0\n 1.1  2.2  3.3  4.4  5.5\n\n\n\n\n\n","category":"method"},{"location":"api/imputation/#Impute.impute!-Union{Tuple{T}, Tuple{T,Impute.Imputor}} where T","page":"Imputation","title":"Impute.impute!","text":"impute!(table, imp; cols=nothing) -> table\n\nImputes the data in a table by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.\n\nArguments\n\nimp::Imputor: the Imputor method to use\ntable: the data to impute\n\nKeyword Arguments\n\ncols: The columns to impute along (default is to impute all columns)\n\nReturns\n\nthe input data with values imputed\n\nExample\n\njulia> using DataFrames; using Impute: Interpolate, impute\n\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n Row │ a          b\n     │ Float64?   Float64?\n─────┼──────────────────────\n   1 │       1.0        1.1\n   2 │       2.0        2.2\n   3 │ missing          3.3\n   4 │ missing    missing\n   5 │       5.0        5.5\n\njulia> impute(df, Interpolate())\n5×2 DataFrame\n Row │ a         b\n     │ Float64?  Float64?\n─────┼────────────────────\n   1 │      1.0       1.1\n   2 │      2.0       2.2\n   3 │      3.0       3.3\n   4 │      4.0       4.4\n   5 │      5.0       5.5\n\n\n\n\n\n","category":"method"},{"location":"api/imputation/#Impute.impute!-Union{Tuple{T}, Tuple{T,Impute.Imputor}} where T<:(AbstractArray{var\"#s13\",1} where var\"#s13\"<:NamedTuple)","page":"Imputation","title":"Impute.impute!","text":"impute!(data::T, imp; kwargs...) -> T where T <: AbstractVector{<:NamedTuple}\n\nSpecial case rowtables which are arrays, but we want to fallback to the tables method.\n\n\n\n\n\n","category":"method"},{"location":"api/imputation/#Impute.impute-Tuple{Any,Impute.Imputor}","page":"Imputation","title":"Impute.impute","text":"impute(data::T, imp; kwargs...) -> T\n\nReturns a new copy of the data with the missing data imputed by the imputor imp. For matrices and tables, data is imputed one variable/column at a time. If this is not the desired behaviour then you should overload this method or specify a different dims value.\n\nArguments\n\ndata: the data to be impute\nimp::Imputor: the Imputor method to use\n\nReturns\n\nthe input data with values imputed\n\nExample\n\njulia> using Impute: Interpolate, impute\n\njulia> v = [1.0, 2.0, missing, missing, 5.0]\n5-element Array{Union{Missing, Float64},1}:\n 1.0\n 2.0\n  missing\n  missing\n 5.0\n\njulia> impute(v, Interpolate())\n5-element Array{Union{Missing, Float64},1}:\n 1.0\n 2.0\n 3.0\n 4.0\n 5.0\n\n\n\n\n\n","category":"method"},{"location":"api/imputation/#Interpolation","page":"Imputation","title":"Interpolation","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.interp","category":"page"},{"location":"api/imputation/#Impute.interp","page":"Imputation","title":"Impute.interp","text":"Impute.interp(data; dims=1)\n\nPerforms linear interpolation between the nearest values in an vector. See Impute.Interpolate for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute\n\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n Row │ a          b\n     │ Float64?   Float64?\n─────┼──────────────────────\n   1 │       1.0        1.1\n   2 │       2.0        2.2\n   3 │ missing          3.3\n   4 │ missing    missing\n   5 │       5.0        5.5\n\njulia> Impute.interp(df)\n5×2 DataFrame\n Row │ a         b\n     │ Float64?  Float64?\n─────┼────────────────────\n   1 │      1.0       1.1\n   2 │      2.0       2.2\n   3 │      3.0       3.3\n   4 │      4.0       4.4\n   5 │      5.0       5.5\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.Interpolate","category":"page"},{"location":"api/imputation/#Impute.Interpolate","page":"Imputation","title":"Impute.Interpolate","text":"Interpolate()\n\nPerforms linear interpolation between the nearest values in an vector. The current implementation is univariate, so each variable in a table or matrix will be handled independently.\n\n!!! Missing values at the head or tail of the array cannot be interpolated if there are no existing values on both sides. As a result, this method does not guarantee that all missing values will be imputed.\n\nExample\n\njulia> using Impute: Interpolate, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, Interpolate(); dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  3.0  4.0  5.0\n 1.1  2.2  3.3  4.4  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#K-Nearest-Neighbors-(KNN)","page":"Imputation","title":"K-Nearest Neighbors (KNN)","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.knn","category":"page"},{"location":"api/imputation/#Impute.knn","page":"Imputation","title":"Impute.knn","text":"Impute.knn(; k=1, threshold=0.5, dist=Euclidean())\n\nImputation using k-Nearest Neighbor algorithm.\n\nKeyword Arguments\n\nk::Int: number of nearest neighbors\ndist::MinkowskiMetric: distance metric suppports by NearestNeighbors.jl (Euclidean, Chebyshev, Minkowski and Cityblock)\nthreshold::AbsstractFloat: thershold for missing neighbors\n\nReference\n\nTroyanskaya, Olga, et al. \"Missing value estimation methods for DNA microarrays.\" Bioinformatics 17.6 (2001): 520-525.\n\nExample\n\njulia> using Impute, Missings\n\njulia> data = allowmissing(reshape(sin.(1:20), 5, 4)); data[[2, 3, 7, 9, 13, 19]] .= missing; data\n5×4 Array{Union{Missing, Float64},2}:\n  0.841471  -0.279415  -0.99999   -0.287903\n   missing    missing  -0.536573  -0.961397\n   missing   0.989358    missing  -0.750987\n -0.756802    missing   0.990607    missing\n -0.958924  -0.544021   0.650288   0.912945\n\njulia> result = Impute.knn(data; dims=:cols)\n5×4 Array{Union{Missing, Float64},2}:\n  0.841471  -0.279415  -0.99999   -0.287903\n -0.756802   0.989358  -0.536573  -0.961397\n -0.756802   0.989358  -0.536573  -0.750987\n -0.756802  -0.544021   0.990607   0.912945\n -0.958924  -0.544021   0.650288   0.912945\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.KNN","category":"page"},{"location":"api/imputation/#Impute.KNN","page":"Imputation","title":"Impute.KNN","text":"KNN(; kwargs...)\n\nImputation using k-Nearest Neighbor algorithm.\n\nKeyword Arguments\n\nk::Int: number of nearest neighbors\ndist::MinkowskiMetric: distance metric suppports by NearestNeighbors.jl (Euclidean, Chebyshev, Minkowski and Cityblock)\nthreshold::AbstractFloat: threshold for missing neighbors\n\nReference\n\nTroyanskaya, Olga, et al. \"Missing value estimation methods for DNA microarrays.\" Bioinformatics 17.6 (2001): 520-525.\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#Last-Observation-Carried-Forward-(LOCF)","page":"Imputation","title":"Last Observation Carried Forward (LOCF)","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.locf","category":"page"},{"location":"api/imputation/#Impute.locf","page":"Imputation","title":"Impute.locf","text":"Impute.locf(data; dims=1)\n\nIterates forwards through the data and fills missing data with the last existing observation. See Impute.LOCF for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute\n\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n Row │ a          b\n     │ Float64?   Float64?\n─────┼──────────────────────\n   1 │       1.0        1.1\n   2 │       2.0        2.2\n   3 │ missing          3.3\n   4 │ missing    missing\n   5 │       5.0        5.5\n\njulia> Impute.locf(df)\n5×2 DataFrame\n Row │ a         b\n     │ Float64?  Float64?\n─────┼────────────────────\n   1 │      1.0       1.1\n   2 │      2.0       2.2\n   3 │      2.0       3.3\n   4 │      2.0       3.3\n   5 │      5.0       5.5\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.LOCF","category":"page"},{"location":"api/imputation/#Impute.LOCF","page":"Imputation","title":"Impute.LOCF","text":"LOCF()\n\nLast observation carried forward (LOCF) iterates forwards through the data and fills missing data with the last existing observation. The current implementation is univariate, so each variable in a table or matrix will be handled independently.\n\nSee also:\n\nImpute.NOCB: Next Observation Carried Backward\n\n!!! Missing elements at the head of the array may not be imputed if there is no existing observation to carry forward. As a result, this method does not guarantee that all missing values will be imputed.\n\nExample\n\njulia> using Impute: LOCF, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, LOCF(); dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  2.0  2.0  5.0\n 1.1  2.2  3.3  3.3  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#Next-Observation-Carried-Backward-(NOCB)","page":"Imputation","title":"Next Observation Carried Backward (NOCB)","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.nocb","category":"page"},{"location":"api/imputation/#Impute.nocb","page":"Imputation","title":"Impute.nocb","text":"Impute.nocb(data; dims=1)\n\nIterates backwards through the data and fills missing data with the next existing observation. See Impute.NOCB for details.\n\nExample\n\njulia> using DataFrames; using Impute: Impute\n\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n Row │ a          b\n     │ Float64?   Float64?\n─────┼──────────────────────\n   1 │       1.0        1.1\n   2 │       2.0        2.2\n   3 │ missing          3.3\n   4 │ missing    missing\n   5 │       5.0        5.5\n\njulia> Impute.nocb(df)\n5×2 DataFrame\n Row │ a         b\n     │ Float64?  Float64?\n─────┼────────────────────\n   1 │      1.0       1.1\n   2 │      2.0       2.2\n   3 │      5.0       3.3\n   4 │      5.0       5.5\n   5 │      5.0       5.5\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.NOCB","category":"page"},{"location":"api/imputation/#Impute.NOCB","page":"Imputation","title":"Impute.NOCB","text":"NOCB()\n\nNext observation carried backward (NOCB) iterates backwards through the data and fills missing data with the next existing observation.\n\nSee also:\n\nImpute.LOCF: Last Observation Carried Forward\n\n!!! Missing elements at the tail of the array may not be imputed if there is no existing observation to carry backward. As a result, this method does not guarantee that all missing values will be imputed.\n\nKeyword Arguments\n\nExample\n\njulia> using Impute: NOCB, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, NOCB(); dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  5.0  5.0  5.0\n 1.1  2.2  3.3  5.5  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#Replacement","page":"Imputation","title":"Replacement","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.replace","category":"page"},{"location":"api/imputation/#Impute.replace","page":"Imputation","title":"Impute.replace","text":"Impute.replace(data; values)\n\nReplace missings with one of the specified constant values, depending on the input type. If multiple values of the same type are provided then the first one will be used. If the input data is of a different type then the no replacement will be performed.\n\nKeyword Arguments\n\nvalues::Tuple: A scalar or tuple of different values that should be used to replace missings. Typically, one value per type you're considering imputing for.\n\nExample\n\njulia> using DataFrames, Impute\n\njulia> df = DataFrame(\n           :a => [1.1, 2.2, missing, missing, 5.5],\n           :b => [1, 2, 3, missing, 5],\n           :c => [\"v\", \"w\", \"x\", \"y\", missing],\n       )\n5×3 DataFrame\n Row │ a          b        c\n     │ Float64?   Int64?   String?\n─────┼─────────────────────────────\n   1 │       1.1        1  v\n   2 │       2.2        2  w\n   3 │ missing          3  x\n   4 │ missing    missing  y\n   5 │       5.5        5  missing\n\njulia> Impute.replace(df; values=(NaN, -9999, \"NULL\"))\n5×3 DataFrame\n Row │ a         b       c\n     │ Float64?  Int64?  String?\n─────┼───────────────────────────\n   1 │      1.1       1  v\n   2 │      2.2       2  w\n   3 │    NaN         3  x\n   4 │    NaN     -9999  y\n   5 │      5.5       5  NULL\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.Replace","category":"page"},{"location":"api/imputation/#Impute.Replace","page":"Imputation","title":"Impute.Replace","text":"Replace(; value)\n\nReplace missings with one of the specified constant values, depending on the input type. If multiple values of the same type are provided then the first one will be used. If the input data is of a different type then the no replacement will be performed.\n\nKeyword Arguments\n\nvalues::Tuple: A scalar or tuple of different values that should be used to replace missings. Typically, one value per type you're considering imputing for.\n\nExample\n\njulia> using Impute: Replace, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, Replace(; values=0.0); dims=2)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  0.0  0.0  5.0\n 1.1  2.2  3.3  0.0  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#Simple-Random-Sample-(SRS)","page":"Imputation","title":"Simple Random Sample (SRS)","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.srs","category":"page"},{"location":"api/imputation/#Impute.srs","page":"Imputation","title":"Impute.srs","text":"Impute.srs(data; rng=Random.GLOBAL_RNG)\n\nSimple Random Sampling (SRS) imputation is a method for imputing both continuous and categorical variables. Furthermore, it completes imputation while preserving the distributional properties of the variables (e.g., mean, standard deviation).\n\nExample\n\njulia> using DataFrames; using Random; using Impute: Impute\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n│ Row │ a        │ b        │\n│     │ Float64? │ Float64? │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.srs(df; rng=MersenneTwister(1234))\n5×2 DataFrame\n│ Row │ a        │ b        │\n│     │ Float64? │ Float64? │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ 1.0      │ 3.3      │\n│ 4   │ 2.0      │ 3.3      │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.SRS","category":"page"},{"location":"api/imputation/#Impute.SRS","page":"Imputation","title":"Impute.SRS","text":"SRS(; rng=Random.GLOBAL_RNG)\n\nSimple Random Sampling (SRS) imputation is a method for imputing both continuous and categorical variables. Furthermore, it completes imputation while preserving the distributional properties of the variables (e.g., mean, standard deviation).\n\nThe basic idea is that for a given variable, x, with missing data, we randomly draw from the observed values of x to impute the missing elements. Since the random draws from x for imputation are done in proportion to the frequency distribution of the values in x, the univariate distributional properties are generally not impacted; this is true for both categorical and continuous data.\n\nKeyword Arguments\n\nrng::AbstractRNG: A random number generator to use for observation selection\n\nExample\n\njulia> using Random; using Impute: SRS, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, SRS(; rng=MersenneTwister(1234)); dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  1.0  2.0  5.0\n 1.1  2.2  3.3  3.3  5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/#Substitute","page":"Imputation","title":"Substitute","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.substitute","category":"page"},{"location":"api/imputation/#Impute.substitute","page":"Imputation","title":"Impute.substitute","text":"Impute.substitute(data; statistic=nothing)\nImpute.substitute(data; robust=true, weights=nothing)\n\nSubstitute missing values with a summary statistic over the non-missing values.\n\nKeyword Arguments\n\nstatistic: A summary statistic function to be applied to the non-missing values. This function should return a value of the same type as the input data eltype. If this function isn't passed in then the defaultstats function is used to make a best guess.\nrobust: Whether to use median or mean for continuous datasets in defaultstats\nweights: A set of statistical weights to apply to the mean or median in defaultstats.\n\nSee Substitute for details on substitution rules defined in defaultstats.\n\nExample\n\njulia> using DataFrames, Impute\n\n\njulia> df = DataFrame(\n                  :a => [8.9, 2.2, missing, missing, 1.3, 6.2, 3.7, 4.8],\n                  :b => [2, 6, 3, missing, 7, 1, 9, missing],\n                  :c => [true, false, true, true, false, missing, false, true],\n              )\n8×3 DataFrame\n Row │ a          b        c\n     │ Float64?   Int64?   Bool?\n─────┼─────────────────────────────\n   1 │       8.9        2     true\n   2 │       2.2        6    false\n   3 │ missing          3     true\n   4 │ missing    missing     true\n   5 │       1.3        7    false\n   6 │       6.2        1  missing\n   7 │       3.7        9    false\n   8 │       4.8  missing     true\n\njulia> Impute.substitute(df)\n8×3 DataFrame\n Row │ a         b       c\n     │ Float64?  Int64?  Bool?\n─────┼─────────────────────────\n   1 │     8.9        2   true\n   2 │     2.2        6  false\n   3 │     4.25       3   true\n   4 │     4.25       4   true\n   5 │     1.3        7  false\n   6 │     6.2        1   true\n   7 │     3.7        9  false\n   8 │     4.8        4   true\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.Substitute","category":"page"},{"location":"api/imputation/#Impute.Substitute","page":"Imputation","title":"Impute.Substitute","text":"Substitute(; statistic=Impute.defaultstats)\n\nSubstitute missing values with a summary statistic over the non-missing values.\n\nKeyword Arguments\n\nstatistic: A summary statistic function to be applied to the non-missing values. This function should return a value of the same type as the input data eltype. If this function isn't passed in then the Impute.defaultstats function is used to make a best guess.\n\nExample\n\njulia> using Statistics; using Impute: Substitute, impute\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> impute(M, Substitute(); dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  2.0  2.0   5.0\n 1.1  2.2  3.3  2.75  5.5\n\njulia> impute(M, Substitute(; statistic=mean); dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0  2.66667  2.66667  5.0\n 1.1  2.2  3.3      3.025    5.5\n\n\n\n\n\n","category":"type"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.defaultstats","category":"page"},{"location":"api/imputation/#Impute.defaultstats","page":"Imputation","title":"Impute.defaultstats","text":"defaultstats(data[, wv])\n\nA set of default substitution rules using either median or mode based on the eltype of the input data. Specific rules are summarized as follows.\n\nBool elements use mode\nReal elements use median\nInteger elements where nunique(data) / length(data) < 0.25 use mode (ratings, categorical codings, etc)\nInteger elements with mostly unique values use median\n!Number (non-numeric) elements use mode as the safest fallback\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/#SVD","page":"Imputation","title":"SVD","text":"","category":"section"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.svd","category":"page"},{"location":"api/imputation/#Impute.svd","page":"Imputation","title":"Impute.svd","text":"Impute.svd(; kwargs...)\n\nImputes the missing values in a matrix using an expectation maximization (EM) algorithm over low-rank SVD approximations.\n\nKeyword Arguments\n\ninit::Imputor: initialization method for missing values (default: Substitute())\nrank::Union{Int, Nothing}: rank of the SVD approximation (default: nothing meaning start and 0 and increase)\ntol::Float64: convergence tolerance (default: 1e-10)\nmaxiter::Int: Maximum number of iterations if convergence is not achieved (default: 100)\nlimits::Unoin{Tuple{Float64, Float64}, Nothing}: Bound the possible approximation values (default: nothing)\nverbose::Bool: Whether to display convergence progress (default: true)\n\nReferences\n\nTroyanskaya, Olga, et al. \"Missing value estimation methods for DNA microarrays.\" Bioinformatics 17.6 (2001): 520-525.\n\nExample\n\njulia> using Impute, Missings\n\njulia> data = allowmissing(reshape(sin.(1:20), 5, 4)); data[[2, 3, 7, 9, 13, 19]] .= missing; data\n5×4 Array{Union{Missing, Float64},2}:\n  0.841471  -0.279415  -0.99999   -0.287903\n   missing    missing  -0.536573  -0.961397\n   missing   0.989358    missing  -0.750987\n -0.756802    missing   0.990607    missing\n -0.958924  -0.544021   0.650288   0.912945\n\njulia> result = Impute.svd(data; dims=:cols)\n5×4 Array{Union{Missing, Float64},2}:\n  0.841471  -0.279415  -0.99999   -0.287903\n  0.220258   0.555829  -0.536573  -0.961397\n -0.372745   0.989358   0.533193  -0.750987\n -0.756802   0.253309   0.990607   0.32315\n -0.958924  -0.544021   0.650288   0.912945\n\n\n\n\n\n","category":"function"},{"location":"api/imputation/","page":"Imputation","title":"Imputation","text":"Impute.SVD","category":"page"},{"location":"api/imputation/#Impute.SVD","page":"Imputation","title":"Impute.SVD","text":"SVD(; kwargs...)\n\nImputes the missing values in a matrix using an expectation maximization (EM) algorithm over low-rank SVD approximations.\n\nKeyword Arguments\n\ninit::Imputor: initialization method for missing values (default: Substitute())\nrank::Union{Int, Nothing}: rank of the SVD approximation (default: nothing meaning start and 0 and increase)\ntol::Float64: convergence tolerance (default: 1e-10)\nmaxiter::Int: Maximum number of iterations if convergence is not achieved (default: 100)\nlimits::Unoin{Tuple{Float64, Float64}, Nothing}: Bound the possible approximation values (default: nothing)\nverbose::Bool: Whether to display convergence progress (default: true)\n\nReferences\n\nTroyanskaya, Olga, et al. \"Missing value estimation methods for DNA microarrays.\" Bioinformatics 17.6 (2001): 520-525.\n\n\n\n\n\n","category":"type"},{"location":"api/filtering/#Filtering","page":"Filtering","title":"Filtering","text":"","category":"section"},{"location":"api/filtering/","page":"Filtering","title":"Filtering","text":"Impute.filter","category":"page"},{"location":"api/filtering/#Impute.filter","page":"Filtering","title":"Impute.filter","text":"Impute.filter([f,] data; dims)\n\nFilters values, rows, columns or slices of data that should be removed. The default function f will removing missings, or any rows, columns or slices containing missings.\n\nExamples\n\njulia> using DataFrames; using Impute: Impute\n\n\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n Row │ a          b\n     │ Float64?   Float64?\n─────┼──────────────────────\n   1 │       1.0        1.1\n   2 │       2.0        2.2\n   3 │ missing          3.3\n   4 │ missing    missing\n   5 │       5.0        5.5\n\njulia> Impute.filter(df; dims=:cols)\n0×0 DataFrame\n\njulia> Impute.filter(df; dims=:rows)\n3×2 DataFrame\n Row │ a        b\n     │ Float64  Float64\n─────┼──────────────────\n   1 │     1.0      1.1\n   2 │     2.0      2.2\n   3 │     5.0      5.5\n\n\n\n\n\n","category":"function"},{"location":"api/filtering/","page":"Filtering","title":"Filtering","text":"Impute.Filter","category":"page"},{"location":"api/filtering/#Impute.Filter","page":"Filtering","title":"Impute.Filter","text":"Filter([f])\n\nUses a function f to identify values, rows, columns or slices of data that should be removed during an apply call. The default function f will removing missings, or any rows, columns or slices containing missings.\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"api/validation/","page":"Validation","title":"Validation","text":"Modules = [Impute]\nPages = [\"validators.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/validation/#Impute.Validator","page":"Validation","title":"Impute.Validator","text":"Validator\n\nAn Validator stores settings for checking the validity of a AbstractArray or Tables.table containing missing values. New validations are expected to subtype Impute.Validator and, at minimum, implement the _validate(data::AbstractArray{Union{T, Missing}}, ::<MyValidator>) method.\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#Impute.validate-Tuple{AbstractArray,Impute.Validator}","page":"Validation","title":"Impute.validate","text":"validate(data::AbstractArray, v::Validator; dims=:)\n\nIf the validator v fails then an error is thrown, otherwise the data provided is returned without mutation. See Validator for the minimum internal _validate call requirements.\n\nArguments\n\ndata::AbstractArray: the data to be impute along dimensions dims\nv::Validator: the validator to apply\n\nKeywords\n\ndims: The dimension to apply the _validate along (default is :)\n\nReturns\n\nthe input data if no error is thrown.\n\nThrows\n\nAn error when the test fails\n\njulia> using Test; using Impute: Threshold, ThresholdError, validate\n\njulia> M = [1.0 2.0 missing missing 5.0; 1.1 2.2 3.3 missing 5.5]\n2×5 Array{Union{Missing, Float64},2}:\n 1.0  2.0   missing  missing  5.0\n 1.1  2.2  3.3       missing  5.5\n\njulia> @test_throws ThresholdError validate(M, Threshold())\nTest Passed\n      Thrown: ThresholdError\n\n\n\n\n\n","category":"method"},{"location":"api/validation/#Impute.validate-Tuple{Any,Impute.Validator}","page":"Validation","title":"Impute.validate","text":"validate(table, v::Validator; cols=nothing)\n\nApplies the validator v to the table 1 column at a time; if this is not the desired behaviour custom validate methods should overload this method. See Validator for the minimum internal _validate call requirements.\n\nArguments\n\ntable: the data to impute\nv: the validator to apply\n\nKeyword Arguments\n\ncols: The columns to impute along (default is to impute all columns)\n\nReturns\n\nthe input data if no error is thrown.\n\nThrows\n\nAn error when any column doesn't pass the test\n\nExample\n\njulia> using DataFrames, Test; using Impute: Threshold, ThresholdError, validate\n\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrame\n Row │ a          b\n     │ Float64?   Float64?\n─────┼──────────────────────\n   1 │       1.0        1.1\n   2 │       2.0        2.2\n   3 │ missing          3.3\n   4 │ missing    missing\n   5 │       5.0        5.5\n\njulia> @test_throws ThresholdError validate(df, Threshold())\nTest Passed\n      Thrown: ThresholdError\n\n\n\n\n\n","category":"method"},{"location":"api/validation/#Thresholds","page":"Validation","title":"Thresholds","text":"","category":"section"},{"location":"api/validation/","page":"Validation","title":"Validation","text":"Impute.threshold","category":"page"},{"location":"api/validation/#Impute.threshold","page":"Validation","title":"Impute.threshold","text":"Impute.threshold(data; limit=0.1, kwargs...)\n\nAssert that proportion of missing values in the data do not exceed the limit.\n\nExamples\n\njulia> using DataFrames, Impute\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64  │ Float64  │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.threshold(df)\nERROR: ThresholdError: Missing data limit exceeded 0.1 (0.4)\nStacktrace:\n...\n\njulia> Impute.threshold(df; limit=0.8)\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64  │ Float64  │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/validation/","page":"Validation","title":"Validation","text":"Impute.Threshold","category":"page"},{"location":"api/validation/#Impute.Threshold","page":"Validation","title":"Impute.Threshold","text":"Threshold(; limit=0.1)\n\nAssert that the ratio of missing values in the provided dataset does not exceed to specified limit.\n\nKeyword Arguments\n\nlimit::Real: Allowed proportion of missing values (should be between 0.0 and 1.0).\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#Weighted-Thresholds","page":"Validation","title":"Weighted Thresholds","text":"","category":"section"},{"location":"api/validation/","page":"Validation","title":"Validation","text":"Impute.wthreshold","category":"page"},{"location":"api/validation/#Impute.wthreshold","page":"Validation","title":"Impute.wthreshold","text":"Impute.wthreshold(data; ratio, weights, kwargs...)\n\nAssert that the weighted proportion of missing values in the data do not exceed the limit.\n\nExamples\n\njulia> using DataFrames, Impute\n\njulia> df = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64  │ Float64  │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\njulia> Impute.wthreshold(df; limit=0.4, weights=0.1:0.1:0.5)\nERROR: ThresholdError: Missing data limit exceeded 0.4 (0.4666666666666666)\nStacktrace:\n...\n\njulia> Impute.wthreshold(df; limit=0.4, weights=0.5:-0.1:0.1)\n5×2 DataFrames.DataFrame\n│ Row │ a        │ b        │\n│     │ Float64  │ Float64  │\n├─────┼──────────┼──────────┤\n│ 1   │ 1.0      │ 1.1      │\n│ 2   │ 2.0      │ 2.2      │\n│ 3   │ missing  │ 3.3      │\n│ 4   │ missing  │ missing  │\n│ 5   │ 5.0      │ 5.5      │\n\n\n\n\n\n","category":"function"},{"location":"api/validation/","page":"Validation","title":"Validation","text":"Impute.WeightedThreshold","category":"page"},{"location":"api/validation/#Impute.WeightedThreshold","page":"Validation","title":"Impute.WeightedThreshold","text":"WeightedThreshold(; limit, weights)\n\nAssert that the weighted proportion missing values in the provided dataset does not exceed to specified limit. The weighed proportion is calculated as sum(weights[ismissing.(data)]) / sum(weights)\n\nKeyword Arguments\n\nlimit::Real: Allowed proportion of missing values (should be between 0.0 and 1.0).\nweights::AbstractWeights: A set of statistical weights to use when evaluating the importance of each observation.\n\n\n\n\n\n","category":"type"},{"location":"#Impute","page":"Home","title":"Impute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DataFrames, Impute\ndf = Impute.dataset(\"test/table/neuro\") |> DataFrame","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: stable) (Image: latest) (Image: Build Status) (Image: Build status) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Impute.jl provides various methods for handling missing data in Vectors, Matrices and Tables.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"Impute\")","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's start by loading our dependencies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataFrames, Impute","category":"page"},{"location":"","page":"Home","title":"Home","text":"We'll also want some test data containing missings to work with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"df = Impute.dataset(\"test/table/neuro\") |> DataFrame","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our first instinct might be to drop all observations, but this leaves us too few rows to work with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Impute.filter(df; dims=:rows)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We could try imputing the values with linear interpolation, but that still leaves missing data at the head and tail of our dataset:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Impute.interp(df)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can chain multiple simple methods together to give a complete dataset:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Impute.interp(df) |> Impute.locf() |> Impute.nocb()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warning:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Your approach should depend on the properties of you data (e.g., MCAR, MAR, MNAR).\nIn-place calls aren't guaranteedto mutate the original data, but it will try avoid copying if possible. In the future, it may be possible to detect whether in-place operations are permitted on an array or table using traits:\nhttps://github.com/JuliaData/Tables.jl/issues/116\nhttps://github.com/JuliaDiffEq/ArrayInterface.jl/issues/22","category":"page"},{"location":"api/chaining/#Chaining","page":"Chaining","title":"Chaining","text":"","category":"section"},{"location":"api/chaining/","page":"Chaining","title":"Chaining","text":"Modules = [Impute]\nPages = [\"chain.jl\"]\nOrder = [:module, :constant, :type, :function]","category":"page"},{"location":"api/chaining/#Impute.Chain","page":"Chaining","title":"Impute.Chain","text":"Chain{T<:Tuple{Vararg{Transform}}} <: Function\n\nRuns multiple Validators, Filter or Imputors on the same data in the order they're provided.\n\nFields\n\ntransforms::Vector{Union{Validator, Filter, Imputor}}\n\n\n\n\n\n","category":"type"},{"location":"api/chaining/#Impute.Chain-Tuple{Any}","page":"Chaining","title":"Impute.Chain","text":"(C::Chain)(data; kwargs...)\n\nRunnable the \"callable\" chain C on the supplied data.\n\nArguments\n\ndata: our data to impute\n\nKeyword Arguments\n\nkwargs: Keyword arguments that should be applied to each transform (ex dims=:cols)\n\nReturns\n\nour imputed data\n\n\n\n\n\n","category":"method"},{"location":"api/chaining/#Impute.Chain-Tuple{Vararg{Union{Impute.Imputor, Impute.Validator, Impute.DeclareMissings, Impute.Filter},N} where N}","page":"Chaining","title":"Impute.Chain","text":"Chain(transforms::Union{Validator, Filter, Imputor}...) -> Chain\n\nCreates a Chain using the transforms provided (ordering matters).\n\n\n\n\n\n","category":"method"},{"location":"api/chaining/#Base.:∘-Tuple{Union{Impute.Imputor, Impute.Validator, Impute.DeclareMissings, Impute.Filter},Union{Impute.Imputor, Impute.Validator, Impute.DeclareMissings, Impute.Filter}}","page":"Chaining","title":"Base.:∘","text":"Compose new chains with the composition operator\n\nExample\n\njulia> using Impute: Impute, Interpolate, NOCB, LOCF\n\njulia> M = [missing 2.0 missing missing 5.0; 1.1 2.2 missing 4.4 missing]\n2×5 Array{Union{Missing, Float64},2}:\n  missing  2.0  missing   missing  5.0\n 1.1       2.2  missing  4.4        missing\n\njulia> C = Interpolate() ∘ NOCB() ∘ LOCF();\n\njulia> C(M; dims=:rows)\n2×5 Array{Union{Missing, Float64},2}:\n 2.0  2.0  3.0  4.0  5.0\n 1.1  2.2  3.3  4.4  4.4\n\n\n\n\n\n","category":"method"},{"location":"walkthroughs/svd/#SVD-Imputation","page":"SVD","title":"SVD Imputation","text":"","category":"section"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"Often matrices and n-dimensional arrays with missing values can be imputed via a low rank approximation. Impute.jl provides one such method using a single value decomposition. The general idea is to:","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"Fill the missing values with some rough approximates (e.g., mean, median, rand)\nReconstruct this \"completed\" matrix with a low rank SVD approximation (i.e., k largest singular values)\nReplace our initial estimates with the reconstructed values\nRepeat steps 1-3 until convergence (update difference is below a tolerance)","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"To demonstrate how this is useful lets load a reduced MNIST dataset. We'll want both the completed dataset and another dataset with 35% of the values set to -1.0 (indicating missingness).","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"TODO: Update example with more a realistic dataset like some microarray data","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"using Distances, Impute, Plots, Statistics\nmnist = Impute.dataset(\"test/matrix/mnist\");\ncompleted, incomplete = mnist[0.0], mnist[0.25];","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"Alright, before we get started lets have a look at what our incomplete data looks like:","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"heatmap(incomplete; color=:greys);\nsavefig(\"mnist-incomplete-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"(Image: )","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"Okay, so as we'd expect there's a reasonable bit of structure we can exploit. So how does the svd method compare against other common, yet simpler, methods?","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"data = Impute.declaremissings(incomplete; values=-1.0)\n\n# NOTE: SVD performance is almost identical regardless of the `init` setting.\nimputors = [\n    \"0.5\" => Impute.Replace(; values=0.5),\n    \"mean\" => Impute.Substitute(; robust=false),\n    \"median\" => Impute.Substitute(),\n    \"svd\" => Impute.SVD(; tol=1e-2),\n]\n\nresults = map(last.(imputors)) do imp\n    r = Impute.impute(data, imp; dims=:)\n    return nrmsd(completed, r)\nend\n\nbar(first.(imputors), results);\nsavefig(\"svd-results-plot.svg\"); nothing # hide","category":"page"},{"location":"walkthroughs/svd/","page":"SVD","title":"SVD","text":"(Image: )","category":"page"}]
}
